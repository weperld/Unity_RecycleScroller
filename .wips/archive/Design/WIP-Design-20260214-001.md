# Design ë‹¨ê³„ ë…ë¦½ WIP

## ê¸°ë³¸ ì •ë³´
- **WorkID**: WIP-20260214-001
- **ìŠ¤í…Œì´ì§€**: Design
- **ë‹´ë‹¹ ì—ì´ì „íŠ¸**: architect
- **ìƒì„±ì¼**: 2026-02-14
- **ìƒíƒœ**: ì™„ë£Œ

---

## ğŸ”’ ì ˆëŒ€ ê·œì¹™ ì¤€ìˆ˜ í™•ì¸ (ê°•ì œ)

### architect ì ˆëŒ€ ê·œì¹™ ì²´í¬
- [x] ë¬´ì¡°ê±´ ìºìŠ¤íŒ… (Type)cast ë‚¨ìš©í•˜ì§€ ì•ŠìŒ
- [x] GetComponent í˜¸ì¶œ ê²°ê³¼ë¥¼ ìºì‹±í•¨
- [x] Update/LateUpdateì—ì„œ GC ìœ ë°œ ì½”ë“œ ì—†ìŒ
- [x] ë¹ˆ catch ë¸”ë¡ì´ ì—†ìŒ
- [x] ì—ë””í„° ì½”ë“œê°€ ëŸ°íƒ€ì„ì— í¬í•¨ë˜ì§€ ì•ŠìŒ (#if UNITY_EDITOR)
- [x] Object Pool ì‚¬ìš© ì‹œ ì°¸ì¡° ì •ë¦¬ ì™„ë£Œ
- [x] ë¹ˆ catch ë¸”ë¡ ì—†ìŒ
- [x] í…ŒìŠ¤íŠ¸ ì‚­ì œí•˜ì§€ ì•ŠìŒ
- [x] ì»¤ë°‹ ì—†ì´ íŒŒì¼ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ì ìš”ì²­ ì „)
- [x] ë‹¨ì–¸ ì—†ì´ ì¶”ì¸¡í•˜ì§€ ì•ŠìŒ
- [x] ê°œë°œ íŒŒì´í”„ë¼ì¸ ì§€ì¹¨ì„ íŒŒê´´í•˜ì§€ ì•ŠìŒ
- [x] ëª¨ë“  ìœ„ë°˜ì´ ì—†ìŒì„ í™•ì¸í•¨

---

## ì§€ì‹œ ì •ë³´

### ì‘ì—… ëŒ€ìƒ (Target)
- RecycleScrollbarì˜ í•¸ë“¤ ì‚¬ì´ì¦ˆ ë™ì  ì¡°ì • ê¸°ëŠ¥ êµ¬í˜„
- ë¹„ë£¨í”„ ëª¨ë“œ: Elastic ì˜¤ë²„ìŠˆíŠ¸ ì‹œ í•¸ë“¤ ì‚¬ì´ì¦ˆ ì¶•ì†Œ í”¼ë“œë°±
- ë£¨í”„ ëª¨ë“œ: 3ê°œ í•¸ë“¤ ìœ„ì¹˜ ì´ë™ â†’ 2ê°œ í•¸ë“¤ ì‚¬ì´ì¦ˆ ì „í™˜ ë°©ì‹ìœ¼ë¡œ ë³€ê²½

### ë³€ê²½ íŒŒì¼ (Files)
- `RecycleScrollbar.cs` â€” í•µì‹¬ ìˆ˜ì • (UpdateVisuals, UpdateLoopHandles, ResetSubHandlePosition, CreateHandles)
- `RecycleScrollbarDrawer.cs` â€” ì—ë””í„° ì—…ë°ì´íŠ¸ (í•„ìš” ì‹œ)

### í•„ìˆ˜ ì¡°ê±´ (Requirements)
- ì™¸ë¶€(RecycleScroller)ì—ì„œ offset ì „ë‹¬ ì—†ì´ valueë§Œìœ¼ë¡œ ìì²´ ì²˜ë¦¬
- IRecycleScrollbarDelegate ì¸í„°í˜ì´ìŠ¤ ë³€ê²½ ì—†ìŒ
- ë¹„ë£¨í”„/ë£¨í”„ ëª¨ë“œ ëª¨ë‘ ê¸°ì¡´ ìŠ¤í¬ë¡¤ ë™ì‘ì— ì˜í–¥ ì—†ìŒ
- FixedHandleSize ì´í•˜ë¡œë„ Elastic ì¶•ì†Œ í—ˆìš© (ì‚¬ìš©ì ê²°ì •)

### Gate-1 ì¸ê³„ ì‚¬í•­ (architect í¬ë¡œìŠ¤ì²´í¬)
1. **(í•„ìˆ˜)** ì˜¤ë²„ìŠˆíŠ¸ ê³„ì‚°ì— `m_Value` ì§ì ‘ ì‚¬ìš© (`value` getterëŠ” stepped ë°˜ì˜¬ë¦¼)
2. **(ê¶Œê³ )** Elastic ì¶•ì†Œë¥¼ `DisplaySize` í”„ë¡œí¼í‹°ê°€ ì•„ë‹Œ `UpdateVisuals()` ë‚´ ë¡œì»¬ ê³„ì‚°ìœ¼ë¡œ ì²˜ë¦¬
3. **(ê¶Œê³ )** ë£¨í”„ ì„œë¸Œ í•¸ë“¤ ë¶€ëª¨ ë³€ê²½ ì‹œ ì•µì»¤/í”¼ë²— ì„¤ì • ê²€ì¦

---

## ì‘ì—… ì§„í–‰ ë‚´ìš©

### 1ë‹¨ê³„: í™•ì¸ ë° ë¶„ì„ (Confirm & Analyze)
- [x] ê³„íš ë¬¸ì„œ í™•ì¸
- [x] ê¸°ì¡´ ì•„í‚¤í…ì²˜ ë¶„ì„
- [x] ê¸°ìˆ ì  ì œì•½ì‚¬í•­ íŒŒì•…

### 2ë‹¨ê³„: ê³„íš (Plan)
- [x] ì•„í‚¤í…ì²˜ ì„¤ê³„
- [x] ì¸í„°í˜ì´ìŠ¤ ì •ì˜
- [x] ê¸°ìˆ ì  ê²€ì¦

### 3ë‹¨ê³„: ì‹¤í–‰ (Execute)
- [x] ì„¤ê³„ ë¬¸ì„œ ì‘ì„±
- [x] **ìˆ˜ë ´ ë¶„ì„**: ì„¤ê³„ ê²°ê³¼ë¬¼ì— ëŒ€í•œ ë³´ì™„ ì‚¬í•­ ë„ì¶œ
- [x] ë³´ì™„ ì‚¬í•­ ë¶„ë¥˜ (í•„ìˆ˜/ì„ íƒ) ë° í•„ìˆ˜ ë³´ì™„ ì‚¬í•­ ë°˜ì˜
- [x] ìˆ˜ë ´ í™•ì¸: í•„ìˆ˜ ë³´ì™„ ì‚¬í•­ 0ê±´ ë‹¬ì„±
- [x] ì”ì¡´ ì„ íƒ ë³´ì™„ ì‚¬í•­ ëª©ë¡ ê¸°ë¡
- [x] ì‚¬ìš©ì í™•ì¸ ìš”ì²­
- [x] ì‚¬ìš©ì ì‘ë‹µ ê¸°ë¡: **ìŠ¹ì¸ (y)**
- [x] Gate-2 ê²€ì¦ ì™„ë£Œ: **í†µê³¼**

---

## ì§„ì²™ë„
- **ì§„ì²™ë„**: 100%

---

## ì„¤ê³„ ê²°ê³¼

### A. ë¹„ë£¨í”„ ëª¨ë“œ â€” Elastic í•¸ë“¤ ì‚¬ì´ì¦ˆ ì¶•ì†Œ

#### ì›ë¦¬
valueê°€ [0, 1] ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ì–‘(ì˜¤ë²„ìŠˆíŠ¸)ì„ ê°ì§€í•˜ì—¬ í•¸ë“¤ì˜ ì‹œê°ì  ì‚¬ì´ì¦ˆë¥¼ ë™ì  ì¶•ì†Œ.
Unity ScrollRectì˜ `size = Clamp01((ViewSize - Abs(offset)) / ContentSize)` ê³µì‹ì„ value ê¸°ë°˜ìœ¼ë¡œ ë³€í™˜.

#### ìˆ˜ì‹ ë„ì¶œ

Unity ScrollRect ì›ë³¸:
```
scrollbar.size = Clamp01((viewSize - abs(offset)) / contentSize)
```

normalizedPositionê³¼ offsetì˜ ê´€ê³„:
```
overValue = abs(normalizedPosition - clamp01(normalizedPosition))
offset = overValue * (contentSize - viewSize)
```

ëŒ€ì… ë³€í™˜:
```
size = Clamp01((viewSize - overValue * (contentSize - viewSize)) / contentSize)
     = Clamp01(viewSize/contentSize - overValue * (1 - viewSize/contentSize))
     = Clamp01(naturalSize - overValue * (1 - naturalSize))
```

RecycleScrollbar ì ìš©:
```
elasticDisplaySize = Clamp01(displaySize - overValue * (1 - size))
```
- `displaySize` = DisplaySize (FixedHandleSize ì ìš©ëœ ê°’) â†’ ì˜¤ë²„ìŠˆíŠ¸ ì—†ì„ ë•Œ ê¸°ì¤€
- `size` = m_Size (ìì—° ë¹„ìœ¨) â†’ ì¶•ì†Œ ì†ë„ ê²°ì •
- `overValue` ì¦ê°€ ì‹œ displaySize ì´í•˜, size ì´í•˜ë¡œë„ ì¶•ì†Œ ê°€ëŠ¥

#### ë³€ê²½ ìœ„ì¹˜: `UpdateVisuals()` (line 425)

**í˜„ì¬ ì½”ë“œ** (ë¹„ë£¨í”„ ë¶„ê¸°):
```csharp
float displaySize = DisplaySize;
float movementScale = 1f - displaySize;
float movement = Mathf.Clamp01(value) * movementScale;
```

**ë³€ê²½ í›„**:
```csharp
float displaySize = DisplaySize;

// Elastic í•¸ë“¤ ì‚¬ì´ì¦ˆ ì¶•ì†Œ (ë¹„ë£¨í”„ ëª¨ë“œ ì „ìš©)
float elasticDisplaySize = displaySize;
if (!IsLoopMode)
{
    float overValue = m_Value < 0f ? -m_Value : (m_Value > 1f ? m_Value - 1f : 0f);
    if (overValue > 0f)
        elasticDisplaySize = Mathf.Clamp01(displaySize - overValue * (1f - size));
}

// ë¹„ë£¨í”„: elasticDisplaySize ì‚¬ìš©, ë£¨í”„: ê¸°ì¡´ displaySize ì‚¬ìš©
float visualSize = IsLoopMode ? displaySize : elasticDisplaySize;
```

#### í•µì‹¬ ì„¤ê³„ ê²°ì •
1. **`m_Value` ì‚¬ìš©**: `value` getterê°€ ì•„ë‹Œ `m_Value`ë¥¼ ì§ì ‘ ì°¸ì¡° (stepped ë°˜ì˜¬ë¦¼ íšŒí”¼)
2. **ë¡œì»¬ ë³€ìˆ˜**: `DisplaySize` í”„ë¡œí¼í‹° ìì²´ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠìŒ â†’ `UpdateDrag()`/`UpdateDragForLoop()`ì˜ `remainingSize` ê³„ì‚°ì— ì˜í–¥ ì—†ìŒ
3. **ì¶•ì†Œ í•œê³„**: `Clamp01`ë¡œ 0 ì´í•˜ ë°©ì§€, FixedHandleSize í•˜í•œ ë¬´ì‹œ (ì‚¬ìš©ì ê²°ì •)
4. **í•¸ë“¤ ìœ„ì¹˜**: ê¸°ì¡´ëŒ€ë¡œ `Clamp01(value) * movementScale` ìœ ì§€ (ìœ„ì¹˜ ë³€ê²½ ì—†ìŒ)

#### ê¸°ì¡´ ë™ì‘ í˜¸í™˜ì„±
- `Clamped` MovementType: valueê°€ í•­ìƒ [0,1]ì´ë¯€ë¡œ overValue=0, elasticDisplaySize=displaySize â†’ **ë¬´ì˜í–¥**
- `Elastic` MovementType: overValue>0ì¼ ë•Œë§Œ ì¶•ì†Œ ë°œë™ â†’ **ì˜ë„í•œ ë™ì‘**
- ì§ì ‘ ë“œë˜ê·¸ (`UpdateDrag`): Clamp01 ì ìš©í•˜ë¯€ë¡œ overValue ë°œìƒ ì•ˆ í•¨ â†’ **ë¬´ì˜í–¥**
- `DisplaySize` í”„ë¡œí¼í‹° ë¶ˆë³€: ë“œë˜ê·¸ `remainingSize` ê³„ì‚° ë¶ˆë³€ â†’ **ë¬´ì˜í–¥**

---

### B. ë£¨í”„ ëª¨ë“œ â€” í•¸ë“¤ ì‚¬ì´ì¦ˆ ì „í™˜

#### ì›ë¦¬
3ê°œ í•¸ë“¤ ìœ„ì¹˜ ì´ë™(í˜„ì¬) â†’ ë©”ì¸ í•¸ë“¤ + 2ê°œ ì„œë¸Œ í•¸ë“¤ ì‚¬ì´ì¦ˆ ì „í™˜(ìƒˆ êµ¬ì¡°).
ì„œë¸Œ í•¸ë“¤ì„ HandleContainerRectì˜ ì–‘ ëì— ê³ ì •í•˜ê³ , ë©”ì¸ í•¸ë“¤ì´ ê²½ê³„ë¥¼ ë„˜ì„ ë•Œ wrap ì–‘ë§Œí¼ ì„œë¸Œ í•¸ë“¤ ì‚¬ì´ì¦ˆë¥¼ ë™ì  ì„¤ì •.

#### êµ¬ì¡° ë³€ê²½

**í˜„ì¬ êµ¬ì¡°** (íê¸°):
```
HandleContainerRect (Sliding Area)
  â””â”€ handleRect (ë©”ì¸ í•¸ë“¤) â† anchor ê¸°ë°˜ ì´ë™
       â”œâ”€ m_leftHandle  â† ìì‹, anchoredPosition = -ScrollbarRectSize
       â””â”€ m_rightHandle â† ìì‹, anchoredPosition = +ScrollbarRectSize
```
- 3ê°œ í•¸ë“¤ ì¼ì²´ ì´ë™, ë§ˆìŠ¤í¬ë¡œ ë³´ì´ëŠ” ê²ƒë§Œ í‘œì‹œ

**ìƒˆ êµ¬ì¡°**:
```
HandleContainerRect (Sliding Area)
  â”œâ”€ handleRect     (ë©”ì¸ í•¸ë“¤) â† anchor ê¸°ë°˜ ì´ë™ (ê¸°ì¡´ëŒ€ë¡œ)
  â”œâ”€ m_leftHandle   (ì‹œì‘ ì—ì§€) â† anchor ê³ ì • (0 side), ì‚¬ì´ì¦ˆ ë™ì 
  â””â”€ m_rightHandle  (ë ì—ì§€)   â† anchor ê³ ì • (1 side), ì‚¬ì´ì¦ˆ ë™ì 
```
- ë©”ì¸ í•¸ë“¤: ê¸°ì¡´ê³¼ ë™ì¼í•˜ê²Œ ì´ë™ (anchorê°€ [0,1] ë²”ìœ„ë¥¼ ë„˜ì„ ìˆ˜ ìˆìŒ)
- ì„œë¸Œ í•¸ë“¤: ì—ì§€ì— ê³ ì •, wrap ë°œìƒ ì‹œì—ë§Œ ì‚¬ì´ì¦ˆ > 0ìœ¼ë¡œ í‘œì‹œ

#### Wrap ê³„ì‚° ë¡œì§

`UpdateVisuals()`ì—ì„œ ë©”ì¸ í•¸ë“¤ anchor ì„¤ì • í›„:

```csharp
if (IsLoopMode)
{
    float mainAnchorMin = anchorMin[(int)axis];
    float mainAnchorMax = anchorMax[(int)axis];

    // ì‹œì‘ ì—ì§€ wrap: ë©”ì¸ í•¸ë“¤ì´ ë(1)ì„ ë„˜ì„ ë•Œ â†’ ì‹œì‘(0)ì—ì„œ í‘œì‹œ
    float startWrap = Mathf.Max(0f, mainAnchorMax - 1f);

    // ë ì—ì§€ wrap: ë©”ì¸ í•¸ë“¤ì´ ì‹œì‘(0) ì•ìœ¼ë¡œ ê°ˆ ë•Œ â†’ ë(1)ì—ì„œ í‘œì‹œ
    float endWrap = Mathf.Max(0f, -mainAnchorMin);

    UpdateLoopHandles(startWrap, endWrap);
}
```

**Direction ë…ë¦½**: anchorMin/anchorMax ê³„ì‚°ì´ ì´ë¯¸ `reverseValue`ë¥¼ ë°˜ì˜í•˜ë¯€ë¡œ, wrap ê³„ì‚°ì€ ë°©í–¥ì— ë¬´ê´€í•˜ê²Œ ë™ì¼.

#### ê²€ì¦ (ìˆ˜í‰ LeftToRight, displaySize=0.2)

| movement | anchorMin | anchorMax | startWrap | endWrap | ì‹œê°ì  ê²°ê³¼ |
|----------|-----------|-----------|-----------|---------|-------------|
| 0.3 | 0.3 | 0.5 | 0 | 0 | ë©”ì¸ë§Œ í‘œì‹œ |
| 0.9 | 0.9 | 1.1 | 0.1 | 0 | ë©”ì¸(0.9~1.0) + ì‹œì‘ì—ì§€(0~0.1) |
| -0.05 | -0.05 | 0.15 | 0 | 0.05 | ë©”ì¸(0~0.15) + ëì—ì§€(0.95~1.0) |
| 1.0 | 1.0 | 1.2 | 0.2 | 0 | ì‹œì‘ì—ì§€=ì „ì²´(0~0.2), ë©”ì¸ì€ ë°– |

#### ë³€ê²½ ë©”ì„œë“œ ìƒì„¸

##### `CreateHandles()` (line 850)
```csharp
private void CreateHandles()
{
    if (handleRect == null) return;

    CreateSubHandle(ref m_leftHandle, "Sub Handle 0");
    CreateSubHandle(ref m_rightHandle, "Sub Handle 1");

    // ë³€ê²½: ë¶€ëª¨ë¥¼ handleRect â†’ HandleContainerRectë¡œ
    m_leftHandle.SetParent(HandleContainerRect);
    m_rightHandle.SetParent(HandleContainerRect);

    ResetSubHandlesPosition();
    return;

    void CreateSubHandle(ref RectTransform subHandle, string name)
    {
        if (subHandle == null) subHandle = Instantiate(handleRect, HandleContainerRect);
        subHandle.name = name;
        subHandle.gameObject.SetActive(true);
    }
}
```

##### `ResetSubHandlePosition()` (line 819)
```csharp
private void ResetSubHandlePosition(RectTransform subHandle, bool isStartEdge)
{
    if (subHandle == null) return;

    bool loopActive = Del != null && Del.IsLoopScrollable;
    subHandle.gameObject.SetActive(loopActive);
    if (!loopActive) return;

    // anchor ê¸°ë°˜ ì—ì§€ ê³ ì • (ì‚¬ì´ì¦ˆ 0ìœ¼ë¡œ ì´ˆê¸°í™”)
    Vector2 aMin = Vector2.zero;
    Vector2 aMax = Vector2.one;

    if (isStartEdge)
    {
        aMin[(int)axis] = 0f;
        aMax[(int)axis] = 0f; // ì‚¬ì´ì¦ˆ 0
    }
    else
    {
        aMin[(int)axis] = 1f;
        aMax[(int)axis] = 1f; // ì‚¬ì´ì¦ˆ 0
    }

    subHandle.anchorMin = aMin;
    subHandle.anchorMax = aMax;
    subHandle.pivot = new Vector2(0.5f, 0.5f);
    subHandle.anchoredPosition = Vector2.zero;
    subHandle.sizeDelta = Vector2.zero;
}
```

##### `UpdateLoopHandles()` (line 811)
```csharp
private void UpdateLoopHandles(float startWrap, float endWrap)
{
    if (m_leftHandle)
    {
        Vector2 aMin = Vector2.zero;
        Vector2 aMax = Vector2.one;
        aMin[(int)axis] = 0f;
        aMax[(int)axis] = startWrap;
        m_leftHandle.anchorMin = aMin;
        m_leftHandle.anchorMax = aMax;
        m_leftHandle.anchoredPosition = Vector2.zero;
        m_leftHandle.sizeDelta = Vector2.zero;
        m_leftHandle.gameObject.SetActive(startWrap > 0.001f);
    }

    if (m_rightHandle)
    {
        Vector2 aMin = Vector2.zero;
        Vector2 aMax = Vector2.one;
        aMin[(int)axis] = 1f - endWrap;
        aMax[(int)axis] = 1f;
        m_rightHandle.anchorMin = aMin;
        m_rightHandle.anchorMax = aMax;
        m_rightHandle.anchoredPosition = Vector2.zero;
        m_rightHandle.sizeDelta = Vector2.zero;
        m_rightHandle.gameObject.SetActive(endWrap > 0.001f);
    }
}
```

**ê¸°ì¡´ í˜¸ì¶œë¶€ ë³€ê²½**:
- `Set()` â†’ `UpdateLoopScrollState()` â†’ `UpdateLoopHandles()`: ê¸°ì¡´ ì¸ì ì—†ëŠ” í˜¸ì¶œì„ ì œê±°í•˜ê³ , `UpdateVisuals()` ë‚´ì—ì„œ wrap ê³„ì‚° í›„ í˜¸ì¶œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í†µí•©
- `SetValueWithoutNotify()`: ê¸°ì¡´ `UpdateLoopHandles()` í˜¸ì¶œ ì œê±° (UpdateVisuals()ì—ì„œ í†µí•© ì²˜ë¦¬)
- `Refresh()`: `UpdateLoopHandles()` â†’ wrap ê°’ ì—†ì´ í˜¸ì¶œí•˜ëŠ” ëŒ€ì•ˆ í•„ìš” (í˜„ì¬ anchor ìƒíƒœ ê¸°ë°˜ ì¬ê³„ì‚°)

##### `UpdateVisuals()` í†µí•© ë³€ê²½

```csharp
private void UpdateVisuals()
{
    // ... ê¸°ì¡´ íŠ¸ë˜ì»¤/ì—ë””í„° ì½”ë“œ ...

    if (m_ContainerRect != null)
    {
        // ... ê¸°ì¡´ ContainerRect íŠ¸ë˜ì»¤/ì˜¤í”„ì…‹ ê°•ì œ ...

        // Handle íŠ¸ë˜ì»¤
        m_Tracker.Add(this, m_HandleRect, ...);

        // ì„œë¸Œ í•¸ë“¤ íŠ¸ë˜ì»¤ (ë£¨í”„ ëª¨ë“œ)
        if (IsLoopMode)
        {
            if (m_leftHandle)
                m_Tracker.Add(this, m_leftHandle,
                    DrivenTransformProperties.Anchors
                    | DrivenTransformProperties.AnchoredPosition
                    | DrivenTransformProperties.SizeDelta);
            if (m_rightHandle)
                m_Tracker.Add(this, m_rightHandle,
                    DrivenTransformProperties.Anchors
                    | DrivenTransformProperties.AnchoredPosition
                    | DrivenTransformProperties.SizeDelta);
        }

        Vector2 anchorMin = Vector2.zero;
        Vector2 anchorMax = Vector2.one;

        float displaySize = DisplaySize;

        // === A. ë¹„ë£¨í”„ ëª¨ë“œ: Elastic ì‚¬ì´ì¦ˆ ì¶•ì†Œ ===
        float elasticDisplaySize = displaySize;
        if (!IsLoopMode)
        {
            float overValue = m_Value < 0f ? -m_Value : (m_Value > 1f ? m_Value - 1f : 0f);
            if (overValue > 0f)
                elasticDisplaySize = Mathf.Clamp01(displaySize - overValue * (1f - size));
        }

        // ì‹œê°ì  ì‚¬ì´ì¦ˆ ê²°ì •
        float visualSize = IsLoopMode ? displaySize : elasticDisplaySize;

        // movementScale ê³„ì‚° (ë£¨í”„: naturalSize ê¸°ë°˜, ë¹„ë£¨í”„: visualSize ê¸°ë°˜)
        float movementScale;
        if (IsLoopMode && del != null)
        {
            float naturalSize = del.ShowingSize > 0f ? del.ViewportSize / del.ShowingSize : displaySize;
            movementScale = 1f - naturalSize;
        }
        else
        {
            movementScale = 1f - visualSize;
        }

        float movement = (IsLoopMode ? value : Mathf.Clamp01(value)) * movementScale;

        if (reverseValue)
        {
            anchorMin[(int)axis] = 1 - movement - visualSize;
            anchorMax[(int)axis] = 1 - movement;
        }
        else
        {
            anchorMin[(int)axis] = movement;
            anchorMax[(int)axis] = movement + visualSize;
        }

        m_HandleRect.anchorMin = anchorMin;
        m_HandleRect.anchorMax = anchorMax;
        m_HandleRect.anchoredPosition = Vector2.zero;
        m_HandleRect.sizeDelta = Vector2.zero;

        // === B. ë£¨í”„ ëª¨ë“œ: ì„œë¸Œ í•¸ë“¤ ì‚¬ì´ì¦ˆ ì „í™˜ ===
        if (IsLoopMode)
        {
            float startWrap = Mathf.Max(0f, anchorMax[(int)axis] - 1f);
            float endWrap = Mathf.Max(0f, -anchorMin[(int)axis]);
            UpdateLoopHandles(startWrap, endWrap);
        }
    }
}
```

---

### ê¸°ìˆ ì  ê²°ì • ì‚¬í•­

| ê²°ì • | ì„ íƒ | ê·¼ê±° |
|------|------|------|
| ì˜¤ë²„ìŠˆíŠ¸ ì›ë³¸ ê°’ | `m_Value` (raw) | `value` getterëŠ” numberOfSteps ë°˜ì˜¬ë¦¼ â†’ ì˜¤ë²„ìŠˆíŠ¸ ì •ë°€ë„ ì €í•˜ |
| Elastic ì¶•ì†Œ ìœ„ì¹˜ | `UpdateVisuals()` ë¡œì»¬ ë³€ìˆ˜ | `DisplaySize` ë³€ê²½ ì‹œ UpdateDragì˜ remainingSizeì— ì˜í–¥ |
| ì¶•ì†Œ ìˆ˜ì‹ | `Clamp01(displaySize - over*(1-size))` | Unity ScrollRect ê³µì‹ì˜ ì •í™•í•œ normalized ë³€í™˜ |
| ì„œë¸Œ í•¸ë“¤ ë¶€ëª¨ | `HandleContainerRect` | ë©”ì¸ í•¸ë“¤ê³¼ ë…ë¦½ì  ìœ„ì¹˜/ì‚¬ì´ì¦ˆ ì œì–´ í•„ìš” |
| wrap ê³„ì‚° ë°©ì‹ | anchor ê°’ ê¸°ë°˜ | `reverseValue` ì´ë¯¸ ë°˜ì˜ë˜ì–´ Direction ë…ë¦½ì  |
| UpdateLoopHandles í˜¸ì¶œ | UpdateVisuals() ë‚´ í†µí•© | wrap ê°’ì´ anchor ê³„ì‚° í›„ ì¦‰ì‹œ ê°€ìš©, í˜¸ì¶œ ì¤‘ë³µ ì œê±° |
| ì„œë¸Œ í•¸ë“¤ SetActive | wrap > 0.001f | ë¶€ë™ì†Œìˆ˜ì  ì˜¤ì°¨ ë°©ì§€ìš© epsilon |
| ë¹„ë£¨í”„ movementScale | `1 - visualSize` (elasticDisplaySize) | í•¸ë“¤ ì¶•ì†Œ ì‹œ ì´ë™ ë²”ìœ„ë„ ì—°ë™ |

---

### í˜¸ì¶œ íë¦„ ë³€ê²½

**í˜„ì¬**:
```
Set() â†’ UpdateVisuals()          (ë©”ì¸ í•¸ë“¤ ìœ„ì¹˜/ì‚¬ì´ì¦ˆ)
     â†’ UpdateLoopScrollState()
         â†’ UpdateLoopHandles()   (ì„œë¸Œ í•¸ë“¤ sizeDelta ë³µì‚¬)
         â†’ OnLoopValueChanged

SetValueWithoutNotify() â†’ Set(false)
                        â†’ UpdateLoopHandles()
```

**ë³€ê²½ í›„**:
```
Set() â†’ UpdateVisuals()          (ë©”ì¸ í•¸ë“¤ + ì„œë¸Œ í•¸ë“¤ ëª¨ë‘ ì²˜ë¦¬)
     â†’ UpdateLoopScrollState()
         â†’ OnLoopValueChanged    (UpdateLoopHandles í˜¸ì¶œ ì œê±°)

SetValueWithoutNotify() â†’ Set(false)
                                 (UpdateLoopHandles í˜¸ì¶œ ì œê±°, UpdateVisualsì—ì„œ ì²˜ë¦¬)
```

**Refresh()**: `UpdateLoopHandles()` + `ResetSubHandlesPosition()` â†’ `UpdateVisuals()` + `ResetSubHandlesPosition()`ìœ¼ë¡œ ë³€ê²½

---

## ìˆ˜ë ´ ê²€ì¦ ê²°ê³¼

### ìˆ˜ë ´ ë°˜ë³µ #1
- **ë°œê²¬ëœ ë³´ì™„ ì‚¬í•­**: 4ê±´ (í•„ìˆ˜ 0ê±´ / ì„ íƒ 4ê±´)
- **í•„ìˆ˜ ë³´ì™„ ì‚¬í•­**: ì—†ìŒ
- **ì„ íƒ ë³´ì™„ ì‚¬í•­**:
  1. `Refresh()` ë©”ì„œë“œ ë³€ê²½ ì½”ë“œ ë¯¸ê¸°ìˆ  â†’ Code ë‹¨ê³„ì—ì„œ êµ¬í˜„ (ResetSubHandlesPosition â†’ UpdateVisuals ìˆœì„œ)
  2. ì„œë¸Œ í•¸ë“¤ Graphicì´ `m_graphics` ë¯¸í¬í•¨ â†’ Code ë‹¨ê³„ì—ì„œ CreateHandles()ì—ì„œ ë™ì  ë“±ë¡ ê²€í†  (ê¸°ì¡´ ì´ìŠˆ)
  3. ë¹„ë£¨í”„ `movementScale` ë³€ê²½ ê²€ì¦ â†’ Clamp01(value)=0/1ë¡œ ì—ì§€ ê³ ì • í™•ì¸ë¨, ì¶”ê°€ ê²€ì¦ ë¶ˆìš”
  4. ë§ˆìŠ¤í¬ ì˜ì¡´ì„± â†’ ê¸°ì¡´ ì‹œìŠ¤í…œë„ ë™ì¼, ë³€ê²½ ì‚¬í•­ ì—†ìŒ
- **ê²°ê³¼**: í•„ìˆ˜ ë³´ì™„ ì‚¬í•­ 0ê±´, **ìˆ˜ë ´ ë‹¬ì„±**

---

## í¬ë¡œìŠ¤ì²´í¬ ê²°ê³¼

### architect ìì²´ ê²€ì¦ (Gate-2)
- [x] 1ì°¨ ê²€ì¦ í†µê³¼
- [x] 2ì°¨ ê²€ì¦ í†µê³¼

### developer í¬ë¡œìŠ¤ì²´í¬ (Gate-2)
- [x] í¬ë¡œìŠ¤ì²´í¬ í†µê³¼ (ì¡°ê±´ë¶€)
- ìƒíƒœ: **í†µê³¼**
- Code ì¸ê³„ ì‚¬í•­:
  1. (í•„ìˆ˜) `CreateHandles()`ì—ì„œ ì„œë¸Œ í•¸ë“¤ Graphicì„ `m_graphics`ì— ë™ì  ë“±ë¡
  2. (í•„ìˆ˜) `Refresh()` êµ¬í˜„: `ResetSubHandlesPosition()` â†’ `UpdateVisuals()` ìˆœì„œ ëª…ì‹œ
  3. (ê¶Œê³ ) `UpdateLoopHandles()` ê¸°ì¡´ í˜¸ì¶œë¶€(line 390, 417) ì œê±° ì‹œ ì»´íŒŒì¼ í™•ì¸
  4. (ê¶Œê³ ) ì„œë¸Œ í•¸ë“¤ íŠ¸ë˜ì»¤ ë“±ë¡ ì‹œ IsLoopMode ì¡°ê±´ ê²€ì¦

---

## ì™„ë£Œ/ì·¨ì†Œ ì •ë³´

### ì™„ë£Œ ì‹œ
- **ì™„ë£Œì¼**: (ì™„ë£Œ ì‹œ ê¸°ë¡)
- **ìµœì¢… ì§„ì²™ë„**: 100%

### ì·¨ì†Œ ì‹œ
- **ì·¨ì†Œì¼**: (ì·¨ì†Œ ì‹œ ê¸°ë¡)
- **ì·¨ì†Œ ì‚¬ìœ **: (ì‚¬ìœ )
